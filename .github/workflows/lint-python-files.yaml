# Summary: GitHub CI workflow for checking Python files.

name: Python file checks
run-name: >
  Python lint & format checks for ${{github.event_name}}
  by ${{github.triggering_actor}}

env:
  # Python version to use. Can be overridden when workflow dispatch is used.
  python_ver: '3.11'

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - '**.py'

  push:
    branches:
      - main
    paths:
      - '**.py'

  # Manual on-demand invocations.
  workflow_dispatch:
    inputs:
      python_ver:
        description: 'Python version:'
        type: string

      pylint_ver:
        description: 'Pylint version:'
        type: string

      yapf_ver:
        description: 'Yapf version:'
        type: string

# Cancel previously-started but still active workflow runs on the same branch.
concurrency:
  group: ${{github.workflow}}-${{github.event.pull_request.number||github.ref}}
  cancel-in-progress: true

jobs:
  setup:
    name: Set up Python environment
    runs-on: ubuntu-22.04
    timeout-minutes: 5
    outputs:
      cache_key: ${{steps.parameters.outputs.cache_key}}
      cache_paths: ${{steps.parameters.outputs.cache_paths}}
    steps:
      - name: Check out a copy of the TFQ git repository
        uses: actions/checkout@v4

        # Note: setup-python has a cache facility, but we don't use it here
        # because we want to cache more Python things than setup-python does.
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{inputs.python_ver || env.python_ver}}

      - name: Set cache parameters
        id: parameters
        run: |
          key="${{github.workflow_ref}}-${{hashFiles('requirements.txt')}}"
          echo "cache_key=$key" >> "$GITHUB_OUTPUT"
          # The paths used for actions/cache need to be on separate lines.
          # Constructing a multiline value for an output variable is awkward.
          # shellcheck disable=SC2005
          {
          echo 'cache_paths<<EOF'
          echo "$(pip cache dir)"
          echo "${{env.pythonLocation}}"
          echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Test if the cache already exists
        uses: actions/cache@v4
        id: check_cache
        with:
          lookup-only: true
          key: ${{steps.parameters.outputs.cache_key}}
          path: ${{steps.parameters.outputs.cache_paths}}

      - if: steps.check_cache.outputs.cache-hit != 'true'
        name: Set up the cache
        uses: actions/cache@v4
        id: restore_cache
        with:
          key: ${{steps.parameters.outputs.cache_key}}
          path: ${{steps.parameters.outputs.cache_paths}}

      - if: steps.check_cache.outputs.cache-hit != 'true'
        name: Determine the versions of Pylint and Yapf to use
        id: req
        run: |
          echo "pylint_version=" >> "$GITHUB_OUTPUT"
          echo "yapf_version=" >> "$GITHUB_OUTPUT"
          # Look for the entries in requirements.txt.
          # In case of multiple values in the file, the last one will win.
          number_regex='[0-9]+(\.[0-9]+)?(\.[0-9]+)?'
          while IFS= read -r line; do
            if [[ $line =~ ^pylint.* ]]; then
              if [[ $line =~ $number_regex ]]; then
                version="${BASH_REMATCH[0]}"
                echo "pylint_version=$version" >> "$GITHUB_OUTPUT"
                continue
              fi
            fi
            if [[ $line =~ ^yapf.* ]]; then
              if [[ $line =~ $number_regex ]]; then
                version="${BASH_REMATCH[0]}"
                echo "yapf_version=$version" >> "$GITHUB_OUTPUT"
                continue
              fi
            fi
          done < "requirements.txt"
          # If given a version, use that instead of what's in requirements.txt.
          if [[ "${{inputs.pylint_ver}}" != "" ]]; then
            echo "pylint_version=${{inputs.pylint_ver}}" >> "$GITHUB_OUTPUT"
          fi
          if [[ "${{inputs.yapf_ver}}" != "" ]]; then
            echo "yapf_version=${{inputs.yapf_ver}}" >> "$GITHUB_OUTPUT"
          fi

      - if: steps.check_cache.outputs.cache-hit != 'true'
        name: Install Pylint and Yapf
        run: |
          python -m pip install pylint==${{steps.req.outputs.pylint_version}}
          python -m pip install yapf==${{steps.req.outputs.yapf_version}}

  lint:
    name: Lint Python files
    needs: setup
    runs-on: ubuntu-22.04
    steps:
      - name: Check out a copy of the TFQ git repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{inputs.python_ver || env.python_ver}}

      - name: Restore the Python cache
        uses: actions/cache@v4
        with:
          key: ${{needs.setup.outputs.cache_key}}
          path: ${{needs.setup.outputs.cache_paths}}
          fail-on-cache-miss: true

      - name: Get the list of Python files changed in the triggering event
        id: changes
        uses: tj-actions/changed-files@v45
        # Although this workflow is triggered only if Python files are changed,
        # they might not be the *only* files changed; hence, we have to filter
        # the set of files down to just the Python files.
        with:
          files: |
            **.py

      - name: Foo
        run: |
          pylint "${{steps.changes.outputs.all_changed_files}}"



  # format:
  #   name: Format
  #   runs-on: ubuntu-22.04
  #   steps:
  #     - name: Check out a copy of the TFQ git repository
  #       uses: actions/checkout@v4

  #     - name: Set up Python
  #       uses: actions/setup-python@v5
  #       with:
  #         python-version: ${{inputs.python_ver || env.python_ver}}
  #         cache: 'pip'

  #     - name: Install Yapf
  #       run: |
  #         python -m pip install --upgrade pip
  #         python -m pip install yapf==${{inputs.yapf_ver || env.yapf_ver}}
          
